<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>프롬프트 엔지니어링 핵심 정리</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&family=Bebas+Neue&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css">
</head>
<body>

<div class="header">
  <div class="header-top">
    <h1>프롬프트 엔지니어링</h1>
    <span class="header-badge">핵심 정리</span>
  </div>
  <nav class="tabs">
    <a class="tab-btn active" href="index.html">목차</a>
    <a class="tab-btn" href="ch1.html"><span class="tab-num">1장</span>유형 &amp; 샷 기법</a>
    <a class="tab-btn" href="ch2.html"><span class="tab-num">2장</span>페르소나 패턴</a>
    <a class="tab-btn" href="ch3.html"><span class="tab-num">3장</span>마크다운 활용</a>
    <a class="tab-btn" href="ch4.html"><span class="tab-num">4장</span>표현 강도 &amp; 톤</a>
    <a class="tab-btn" href="ch5.html"><span class="tab-num">5장</span>대안 &amp; 이용자</a>
    <a class="tab-btn" href="ch6.html"><span class="tab-num">6장</span>레시피 &amp; 고급</a>
    <a class="tab-btn" href="ch7.html"><span class="tab-num">7장</span>품질 향상</a>
    <a class="tab-btn" href="ch8.html"><span class="tab-num">8장</span>구조화</a>
    <a class="tab-btn" href="ch9.html"><span class="tab-num">9장</span>비즈니스</a>
    <a class="tab-btn" href="ch10.html"><span class="tab-num">10장</span>자동화</a>
    <a class="tab-btn" href="ch11.html"><span class="tab-num">11장</span>인터랙티브</a>
  </nav>
</div>

<div class="content">
  <div class="chapter-header">
    <div class="chapter-tag">목차</div>
    <div class="chapter-title">ChatGPT · Gemini · Claude에<br>바로 쓰는 실전 프롬프트 가이드</div>
    <div class="chapter-desc">각 장의 프롬프트를 복사하여 AI 챗봇에 붙여넣고, [ ] 안의 내용만 바꾸면 바로 사용할 수 있습니다.</div>
  </div>

  <div class="toc-grid">
    <a class="toc-card" href="ch1.html">
      <div class="toc-num">01</div>
      <div class="toc-title">프롬프트 유형 &amp; 샷 기법</div>
      <div class="toc-desc">서술형·지침형·함수형 3가지 유형과 제로샷·원샷·퓨샷 기법. 구성 방식에 따라 AI 응답 품질이 달라진다.</div>
    </a>
    <a class="toc-card" href="ch2.html">
      <div class="toc-num">02</div>
      <div class="toc-title">페르소나 패턴</div>
      <div class="toc-desc">AI에게 역할을 부여하면 같은 질문에도 전혀 다른 답변이 생성된다. 단일·멀티 페르소나까지 다룬다.</div>
    </a>
    <a class="toc-card" href="ch3.html">
      <div class="toc-num">03</div>
      <div class="toc-title">마크다운 활용법</div>
      <div class="toc-desc">#헤더, 코드블럭, 인용문 등 마크다운 6가지 요소를 프롬프트에 적용하여 AI 파싱 정확도를 높인다.</div>
    </a>
    <a class="toc-card" href="ch4.html">
      <div class="toc-num">04</div>
      <div class="toc-title">표현 강도 &amp; 톤 지정</div>
      <div class="toc-desc">단어 강도에 따라 AI 처리 깊이가 달라진다. 톤(말투)을 지정하면 같은 내용도 완전히 다른 문체로 생성된다.</div>
    </a>
    <a class="toc-card" href="ch5.html">
      <div class="toc-num">05</div>
      <div class="toc-title">대안 접근법 &amp; 이용자 페르소나</div>
      <div class="toc-desc">모든 선택지를 비교하는 대안 패턴과, 답변을 듣는 사람의 프로필을 명시하는 이용자 페르소나 패턴.</div>
    </a>
    <a class="toc-card" href="ch6.html">
      <div class="toc-num">06</div>
      <div class="toc-title">레시피 · 뒤집힌 상호작용 · 인지 검증자</div>
      <div class="toc-desc">단계별 지침을 받는 레시피, AI가 먼저 질문하는 뒤집힌 상호작용, 복잡한 문제를 분해하는 인지 검증자.</div>
    </a>
    <a class="toc-card" href="ch7.html">
      <div class="toc-num">07</div>
      <div class="toc-title">품질 향상 패턴</div>
      <div class="toc-desc">질문 개선·팩트체크·리플렉션. AI 답변의 정확성과 완성도를 높이는 3가지 핵심 기법.</div>
    </a>
    <a class="toc-card" href="ch8.html">
      <div class="toc-num">08</div>
      <div class="toc-title">구조화 패턴</div>
      <div class="toc-desc">아웃라인 확장·컨텍스트 관리자·5W1H. 복잡한 내용을 체계적으로 정리하여 AI가 구조 있게 출력하게 만드는 기법.</div>
    </a>
    <a class="toc-card" href="ch9.html">
      <div class="toc-num">09</div>
      <div class="toc-title">비즈니스 프레임워크</div>
      <div class="toc-desc">CO-STAR·FOCUS·ROSES·RISEN·BAB. 제안서, 협상, 분쟁, 스토리텔링 등 실무 비즈니스 문서에 특화된 5가지 프레임워크.</div>
    </a>
    <a class="toc-card" href="ch10.html">
      <div class="toc-num">10</div>
      <div class="toc-title">자동화·생산성 패턴</div>
      <div class="toc-desc">메타언어 생성·무한 생성. 단축 명령어 설계와 변수 조합으로 반복 작업을 없애고 대량 결과물을 즉시 생성한다.</div>
    </a>
    <a class="toc-card" href="ch11.html">
      <div class="toc-num">11</div>
      <div class="toc-title">인터랙티브 패턴</div>
      <div class="toc-desc">게임플레이 패턴. AI를 텍스트 기반 게임 엔진으로 전환. 장르·주인공·규칙만 바꾸면 어드벤처부터 유아 동화까지 즉시 설계 가능.</div>
    </a>
  </div>

  <!-- ── AI 워크플로우 추천기 ──────────────── -->
  <div class="section" style="margin-top:48px;">
    <div class="section-title">AI 워크플로우 추천기</div>
    <div class="section-desc">하고 싶은 작업을 입력하면, 어떤 프롬프트 기법을 어떤 순서로 써야 하는지 알려드립니다</div>

    <div class="wf-box">
      <div class="wf-input-wrap">
        <textarea id="wf-goal" class="wf-goal" rows="2"
          placeholder="예: 소싱 품목 자동발굴 웹페이지 / 마케팅 콘텐츠 캘린더 / 계약서 법적 검토 자동화..."></textarea>
        <button class="wf-btn" onclick="getWorkflow()">
          <span id="wf-btn-text">추천받기 →</span>
        </button>
      </div>
      <div class="wf-key-row">
        <label class="wf-key-label">OpenAI API Key</label>
        <input type="password" id="wf-key" class="wf-key-input" placeholder="sk-...">
      </div>
    </div>

    <div id="wf-error" class="wf-error" style="display:none;"></div>
    <div id="wf-result" class="wf-result" style="display:none;"></div>
  </div>
</div>

<script>
/* ── 모바일 사이드바 햄버거 버튼 ─────────── */
(function injectMobileNav() {
  const btn = document.createElement('button');
  btn.className = 'menu-toggle';
  btn.setAttribute('aria-label', '메뉴');
  btn.innerHTML = '☰';

  const overlay = document.createElement('div');
  overlay.className = 'sidebar-overlay';

  document.body.prepend(overlay);
  document.body.prepend(btn);

  const sidebar = document.querySelector('.header');
  btn.addEventListener('click', () => {
    const isOpen = sidebar.classList.toggle('sidebar-open');
    overlay.classList.toggle('active', isOpen);
    btn.innerHTML = isOpen ? '✕' : '☰';
  });
  overlay.addEventListener('click', () => {
    sidebar.classList.remove('sidebar-open');
    overlay.classList.remove('active');
    btn.innerHTML = '☰';
  });
  sidebar.querySelectorAll('.tab-btn').forEach(a => {
    a.addEventListener('click', () => {
      sidebar.classList.remove('sidebar-open');
      overlay.classList.remove('active');
      btn.innerHTML = '☰';
    });
  });
})();

const WF_LABELS = {
  ch1: '1장 · 유형 & 샷 기법',
  ch2: '2장 · 페르소나 패턴',
  ch3: '3장 · 마크다운 활용',
  ch4: '4장 · 표현 강도 & 톤',
  ch5: '5장 · 대안 & 이용자',
  ch6: '6장 · 레시피 & 고급'
};
const WF_COLORS = {
  ch1: 'badge-blue', ch2: 'badge-purple', ch3: 'badge-yellow',
  ch4: 'badge-green', ch5: 'badge-blue',  ch6: 'badge-purple'
};

window.addEventListener('DOMContentLoaded', () => {
  const saved = localStorage.getItem('oai-key');
  if (saved) document.getElementById('wf-key').value = saved;

  document.getElementById('wf-goal').addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); getWorkflow(); }
  });

  // 이전 워크플로우 복원
  const prevWf = sessionStorage.getItem('wf-data');
  if (prevWf) {
    try { renderWorkflow(JSON.parse(prevWf), true); } catch(e) {}
  }
});

async function getWorkflow() {
  const goal   = document.getElementById('wf-goal').value.trim();
  const keyEl  = document.getElementById('wf-key');
  const key    = keyEl.value.trim() || localStorage.getItem('oai-key');
  const errEl  = document.getElementById('wf-error');
  const resEl  = document.getElementById('wf-result');
  const btn    = document.querySelector('.wf-btn');
  const btnTxt = document.getElementById('wf-btn-text');

  errEl.style.display = 'none';
  resEl.style.display = 'none';

  if (!goal) { showWfError('작업 내용을 입력해주세요.'); return; }
  if (!key)  { showWfError('OpenAI API Key를 입력해주세요.'); return; }

  localStorage.setItem('oai-key', key);
  btn.disabled = true;
  btnTxt.textContent = '분석 중...';

  const sys = `당신은 프롬프트 엔지니어링 워크플로우 추천 시스템입니다.
사용자의 목표에 맞는 워크플로우를 추천하고, 각 단계의 hint는 반드시 아래 챕터별 양식 구조를 그대로 사용하여 작성하세요.

=== 챕터별 프롬프트 양식 ===

[ch1 - 지침형 프롬프트]
# 역할
[전문가 역할]
# 지시
[구체적인 지시 내용]
# 형식
[원하는 출력 형식]

[ch2 - 페르소나 패턴]
당신은 [역할]입니다.
[경력/배경]을 가지고 있으며,
[전문 분야]에 특화되어 있습니다.
[말투/태도]로 응답하세요.

[ch3 - 마크다운 구조화]
# 역할
[전문가 역할과 경력]

# 작업
[수행할 작업]

"""
[입력 데이터 또는 분석 대상]
"""

# 제약 조건
> [절대 조건]

# 출력 형식
[원하는 출력 형식]

[ch4 - 표현 강도 & 톤]
🔴 최우선 (절대조건) : [가장 중요한 조건]
🟡 중요 (일반조건)   : [일반 조건]
🟢 선택 (권장조건)   : [선호 조건]

[톤/스타일] 스타일로 [작업]을 해주세요.

[ch5 - 대안 접근법]
아래 각 상황에 맞는 가장 적합한 [추천 대상]을 추천하세요.
각 상황은 서로 독립적으로 판단하세요.

상황 A : [상황 설명]
상황 B : [상황 설명]
상황 C : [상황 설명]

각 상황에 대해:
1순위 추천 : [추천 항목] - [이유 한 줄]
2순위 추천 : [추천 항목] - [이유 한 줄]

[ch6 - 레시피 패턴]
# 목표
[달성하고 싶은 목표]

# 현재 상태
- [현재 보유한 것 / 상황]
- [현재 부족한 것 / 제약]

# 요청
위의 목표를 달성하기 위한 단계별 레시피를 작성하세요.

## STEP {번호} : {단계명}
- 할 일     : {구체적 행동}
- 완료 기준 : {다음 단계로 넘어갈 기준}

[ch6 - 역질문 패턴]
제가 원하는 결과물은 [목표]입니다.
바로 만들지 말고, 먼저 아래 항목들을 질문해서
제 답변을 모두 수집한 후 작성하세요.

수집이 필요한 정보:
- [항목 1]
- [항목 2]
- [항목 3]

[ch6 - 인지 검증자 패턴]
아래 질문에 바로 답하지 말고
먼저 이 질문을 정확히 답하기 위해 필요한 하위 질문을 3~5개 도출하세요.
각 하위 질문에 순서대로 답한 뒤 최종 통합 답변을 제시하세요.

질문: [복잡한 질문]

=== 출력 형식 ===
3~5단계 워크플로우를 아래 JSON 형식으로만 반환하세요:
{"summary":"추천 이유 한 줄 (30자 이내)","steps":[{"step":1,"title":"단계명 (8자 이내)","desc":"이 단계가 필요한 이유 (25자 이내)","chapter":"ch2","hint":"위의 해당 챕터 양식 구조를 그대로 사용하여 [ ] 안을 사용자 목표에 맞게 채운 완성 프롬프트"}]}

hint 작성 규칙:
- 반드시 해당 챕터의 양식 구조(#헤더, 들여쓰기, 이모지 등)를 그대로 유지
- [ ] 안의 플레이스홀더를 사용자 목표에 맞는 구체적 내용으로 채울 것
- 즉시 복사해서 ChatGPT/Claude에 붙여넣을 수 있는 완성된 프롬프트로 작성`;

  try {
    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [{ role: 'system', content: sys }, { role: 'user', content: `목표: ${goal}` }],
        response_format: { type: 'json_object' },
        temperature: 0.3
      })
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.error?.message || `API 오류 (${res.status})`);
    }

    const data   = await res.json();
    const parsed = JSON.parse(data.choices[0].message.content);
    renderWorkflow(parsed);

  } catch (e) {
    showWfError(e.message);
  } finally {
    btn.disabled = false;
    btnTxt.textContent = '추천받기 →';
  }
}

function showWfError(msg) {
  const el = document.getElementById('wf-error');
  el.textContent = '⚠ ' + msg;
  el.style.display = 'block';
}

function renderWorkflow(data, restored) {
  if (!restored) sessionStorage.setItem('wf-data', JSON.stringify(data));

  const stepsHtml = data.steps.map((s, i) => {
    const color = WF_COLORS[s.chapter] || 'badge-blue';
    const label = WF_LABELS[s.chapter]  || s.chapter;
    const arrow = i < data.steps.length - 1
      ? '<div class="wf-arrow">→</div>' : '';
    const hintHtml = s.hint
      ? `<div class="wf-hint-block">
           <div class="wf-hint-label">프롬프트 예시</div>
           <div class="wf-hint-text">${s.hint.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>')}</div>
           <button class="wf-hint-copy" onclick="copyHint(this)">복사</button>
         </div>` : '';
    return `
      <div class="wf-step">
        <div class="wf-step-num">STEP ${s.step}</div>
        <div class="wf-step-title">${s.title}</div>
        <div class="wf-step-desc">${s.desc}</div>
        ${hintHtml}
        <a class="badge ${color} wf-step-link" href="${s.chapter}.html">${label} →</a>
      </div>${arrow}`;
  }).join('');

  const el = document.getElementById('wf-result');
  el.innerHTML = `
    <div class="wf-summary">${data.summary}</div>
    <div class="wf-flow">${stepsHtml}</div>`;
  el.style.display = 'block';
  if (!restored) el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function copyHint(btn) {
  const raw = btn.previousElementSibling.innerText;
  navigator.clipboard.writeText(raw).then(() => {
    btn.textContent = '✓ 복사됨';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = '복사'; btn.classList.remove('copied'); }, 2000);
  });
}
</script>

</body>
</html>
